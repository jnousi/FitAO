import numpy as np
import tqdm
import time
import matplotlib.pyplot as plt

# Tools for creating interaction and control matrices


def do_imat(env, modal=None):  # OOMAO method for imat generation
    # Here D denotes interaction matrix, n_validact number of valid actuators and
    # gs_wavelen guide star wavelength. D is generated by poking each actuator
    # individually and setting the resulting slopes at the corresponding column.
    # Commands are scaled by guide star wavelength.
    env.set_noise(-1)
    env.set_V2S(None)
    env.set_S2V(None)
    env.reset()

    n_validact = env.action_space.sample().shape[0]

    if modal is None:
        calibDmCommands = env.get_calibConst() * np.identity(n_validact)
    else:
        calibDmCommands = env.get_calibConst() * modal

    D = np.zeros((env.observation_space.sample().shape[0], calibDmCommands.shape[0]))
    print("Doing imat...")
    env.step(np.zeros(n_validact), showAtmos=False)
    for i in tqdm.tqdm(
        range(calibDmCommands.shape[0])
    ):  # tqdm used to create progress bar
        for j in range(2):  # To compensate 1 frame lag of wfs sensor
            slopes_push = env.step(calibDmCommands[i, :], showAtmos=False)[0]
        for j in range(2):
            slopes_pull = env.step(-1 * calibDmCommands[i, :], showAtmos=False)[0]
        D[:, i] = 0.5 * (np.asarray(slopes_push) - np.asarray(slopes_pull))
        # print(D[:,i])
        # env.render()

    D = D / env.get_calibConst()

    env.step(np.zeros(n_validact), showAtmos=False)

    env.reset_custom_params()

    env.set_V2S(D)

    return D


def do_cmat(env, cond, imat=None, plot=False):
    # Generating pseudo-inverse of the interaction matrix using SVD decomposition.
    # Cond denotes the smallest relative singular value that is filtered from the
    # pseudo-inverse matrix. Relative values are calculated by dividing all the
    # singular values by the largest one. Here M denotes the generated control
    # matrix.
    if imat is None and env.get_V2S() is None:
        imat = do_imat(env)
    elif imat is not None:
        imat = imat
    elif env.get_V2S() is not None:
        imat = env.get_V2S()

    U, S, Vt = np.linalg.svd(imat, full_matrices=True)

    cond_vec = S / S[0]

    if plot:
        plt.plot(cond_vec)
        plt.show()

    # Finds last index where cond_vec > cond and create index list from 0 to it
    idx = np.argmax(cond_vec < cond) - 1

    if idx == -1:
        print("Too small condition! Using all modes")
        idx = len(cond_vec) - 1

    print("CMAT using", idx + 1, "modes of total", len(S))

    iS = np.diag(1 / S[0:idx])

    M1 = np.matmul(np.transpose(Vt)[:, 0:idx], iS)

    M = np.matmul(M1, np.transpose(U[:, 0:idx]))

    env.set_S2V(M)

    return M


def do_F(env, imat=None, cmat=None):
    if imat is None and env.get_V2S() is None:
        imat = do_imat(env)
    elif env.get_V2S() is not None:
        imat = env.get_V2S()

    if cmat is None and env.get_S2V() is None:
        cmat = do_cmat(env)
    elif env.get_S2V() is not None:
        cmat = env.get_S2V()

    F = cmat @ imat

    env.set_F(F)

    return F


def save_mats(env):
    # Save matrices to .npy files
    # TODO: Create own folder for these files
    V2S_filename = env.param_file + "V2S.npy"
    S2V_filename = env.param_file + "S2V.npy"
    pmat_filename = env.param_file + "pmat.npy"
    infmat_filename = env.param_file + "infmat.npy"

    if env.get_V2S() is not None:
        np.save(V2S_filename, env.get_V2S())
    if env.get_S2V() is not None:
        np.save(S2V_filename, env.get_S2V())
    if env.get_pmat() is not None:
        np.save(pmat_filename, env.get_pmat())
    if env.get_infmat() is not None:
        np.save(infmat_filename, env.get_infmat())


def load_mats(env, skip_WFS=False):
    # Load control and interaction matrices to .npy files
    # TODO: Create own folder for these files
    if not skip_WFS:
        V2S_filename = env.param_file + "V2S.npy"
        S2V_filename = env.param_file + "S2V.npy"

        env.set_V2S(np.load(V2S_filename))
        env.set_S2V(np.load(S2V_filename))
    else:
        pmat_filename = env.param_file + "pmat.npy"
        infmat_filename = env.param_file + "infmat.npy"

        env.set_pmat(np.load(pmat_filename))
        env.set_infmat(np.load(infmat_filename))


def create_DM_projection_matrix(env, influ_mat=None):
    # Projection matrix generation, modified from source code by Andreas Obereder
    env.set_pmat(None)

    if influ_mat is None:
        influ_mat = make_influence_matrix(env, 1)
    inv_influ_mat = np.linalg.pinv(influ_mat)

    projection_matrix = inv_influ_mat

    env.set_pmat(projection_matrix)

    return projection_matrix


def make_influence_matrix(env, push_value=1):
    # Influence matrix generation, modified from source code by Andreas Obereder
    env.set_infmat(None)

    wfs_shape = env.get_phase_screen().shape
    dm_shape = env.get_dm_shape()
    offset = (dm_shape.shape[0] - wfs_shape[0]) // 2
    print("wfs: " + str(wfs_shape))
    print("dm: " + str(dm_shape.shape))
    print("offset: " + str(offset))

    # prepare array
    totalpixel = env.get_phase_screen().size
    print("totalpixel: " + str(totalpixel))
    # ntoact = env.get_valid(). Action space does the same thing
    ntoact = env.action_space.sample().shape[0]
    print("ntoact: " + str(ntoact))
    influMat = np.zeros((totalpixel, ntoact))

    # poke actuators for influence matrix
    print("Doing influence matrix...")
    for actuator in tqdm.tqdm(range(ntoact)):
        command = np.zeros(ntoact)
        command[actuator] = 1
        env.step(command, showAtmos=False)
        dm_shape = env.get_dm_shape()
        if offset != 0:
            cropped_shape = dm_shape[
                offset:-offset, offset:-offset
            ]  # cropped to WFS size
        else:
            cropped_shape = dm_shape
        influMat[:, actuator] = cropped_shape.flatten()

    env.set_infmat(influMat)

    return influMat

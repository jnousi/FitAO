classdef env < handle
    % ENV 
    % Jalo Nousiainen 04/2019
    % enviroment for a reinforcement learner
   
    properties
        tel; 
        dm;
        wfs; 
        ngs; 
        V2S;
        S2V;
        V2M;
        M2V;
        M2S;
        S2M;
        science;
        atm;
        d;
        total;
        residue;
        delay;
        slmmse;
        D;
        z;
        zern;
        norm_vec;
        maxRadialDegree;
        std_modes;
        nmodes;
        prev_modes;
        
        contrast;
        C_post;
        C;
    end
    
    methods
        function obj = env(modes)
            
            obj.contrast = true;
            
            addpath([pwd '/OOMAO-master']);
                
                
                
            % set dimensions
            nLenslet = 40;
            nPx = nLenslet*16;


           tel = telescope(8.2,...
                'fieldOfViewInArcMin',2.5,...
                'resolution',nPx,...
                'samplingTime',1/500, 'obStructionRatio', 0.14);


            % guidestar and the science object
            ngs = source('wavelength',photometry.V);
            obj.science = source('wavelength',photometry.H);

            d = tel.D/nLenslet;
            wfs = shackHartmann(nLenslet,nPx,0.7);
            %wfs = pyramid(nLenslet,nPx,'modulation',4);

            % Propagation of the calibration source to the WFS through the telescope
            ngs = ngs.*tel*wfs;
            wfs.INIT
            +wfs;

             % GAIN CALIBRATION
            wfs.pointingDirection = zeros(2,1);
            pixelScale = ngs.wavelength/...
                (2*d*wfs.lenslets.nyquistSampling);
            tipStep = pixelScale/2;
            nStep   = floor(nPx/nLenslet/3)*2;
            sx      = zeros(1,nStep+1);
            u       = 0:nStep;
            wfs.camera.frameListener.Enabled = false;
            wfs.slopesListener.Enabled = false;
            warning('off','oomao:shackHartmann:relay')
            for kStep=u
                ngs.zenith = -tipStep*kStep;
                +ngs;
                drawnow
                sx(kStep+1) = median(wfs.slopes(1:end/2));
            end
            warning('on','oomao:shackHartmann:relay')
            Ox_in  = u*tipStep*constants.radian2arcsec;
            Ox_out = sx*ngs.wavelength/d/2*constants.radian2arcsec;
            %figure
            %plot(Ox_in,Ox_out)
            %grid
            slopesLinCoef = polyfit(Ox_in,Ox_out,1);
            wfs.slopesUnits = 1/slopesLinCoef(1);

            ngs.zenith = 0;
            wfs.pointingDirection = [];

            bif = influenceFunction('monotonic',50/100);
            nActuator = nLenslet + 1;


            dm = deformableMirror(nActuator,...
            'modes',bif,...
            'resolution',nPx,...
            'validActuator',wfs.validActuator);

            ngs=ngs.*tel;                    

            obj.z = true;
            try
                load('calibration_vlt','dmCalib');
            catch
                warning('no precomputed calibration')               
                dmCalib = calibration(dm,wfs,ngs,ngs.wavelength/40);
                save('calibration_vlt','dmCalib')
            end    
            dmCalib.nThresholded = 6;

           
            zern = zernike(2:zernike.nModeFromRadialOrder(modes),'resolution',nPx,'pupil',tel.pupil);
            zern.lex = false;
            obj.zern = zern;                                         
            zern\wfs;
            
            ngs.magnitude = 4;
            wfs.camera.photonNoise = true;
            wfs.camera.readOutNoise = 5;
            wfs.framePixelThreshold = 5;


            %load('std_zernike','std_zernike')
            %std_modes = std_zernike;

            obj.nmodes = ((modes+1).*(modes+2)/2);
            %obj.std_modes = std_modes;        
            obj.std_modes = ones(obj.nmodes-1,1);


            %obj.V2M = pinv(wfs.zern2slopes, 1e-1)*dmCalib.D;
            obj.M2V = dmCalib.M*wfs.zern2slopes;

            % zernike basis on mirror
            obj.M2V = zernike_basis(tel,dm,zern); 
            obj.S2M = pinv(dmCalib.D*obj.M2V);
            
            obj.S2V = dmCalib.M;     
            obj.V2S = dmCalib.D;

            obj.tel = tel; 
            obj.dm = dm;
            obj.wfs = wfs; 
            obj.ngs = ngs;
            obj.d = tel.D/nLenslet;
            obj.delay = 1;
            obj.prev_modes = zeros(obj.nmodes-1,1);

            if obj.contrast                    
                obj.C_post = zeros(3*nPx);
                obj.C = zeros(3*nPx);
            end
                
            
        end        

      function [xData, yData, zernikeData] = new_episode_tel(obj,nIteration,tel,atm)            

            addpath([pwd '/OOMAO_modified']);
            % In the following the atmosphere is given for a r0=15cm in V band and an
            % outer scale of 30m with 3 turbulence layers.


            obj.tel = tel;
            obj.atm = atm;
            %figure(10)
            %imagesc(obj.tel)
            
            % Resetting the DM command
            obj.dm.coefs = 0;
     
            % Propagation throught the atmosphere to the telescope
            obj.ngs=obj.ngs.*obj.tel;
       
        
            % Propagation to the WFS
            obj.ngs=obj.ngs*obj.dm*obj.wfs;
        
            obj.total  = zeros(1,nIteration);
            obj.residue = zeros(1,nIteration);
            
            % run onestep  

            obj.ngs=obj.ngs.*+obj.tel;
            % Variance of the atmospheric wavefront
            obj.total(1) = var(obj.ngs);
            % Propagation to the WFS
            obj.ngs=obj.ngs*obj.dm*obj.wfs;

            % Variance of the residual wavefront
            obj.residue(1) = var(obj.ngs);
            % Computing the DM residual coefficients
           
                
            xData = obj.wfs.xSlopesMap;
            yData = obj.wfs.ySlopesMap;
            
            zernikeData = obj.S2M*obj.wfs.slopes;
            
            zernikeData = zernikeData./obj.std_modes;
            %zernikeData = zernikeData(2:obj.nmodes);
            %zernikeData = zernikeData*obj.wfs.wavefrontUnits;
            
            
                
       end        
        
        
        function [loss, xData, yData, zernikeData, dmCoefs, intcontrol] = run_env_control(obj,control,kIteration)
             
            % Propagation throught the atmosphere to the telescope, +tel means that
            % all the layers move of one step based on the sampling time and the
            % wind vectors of the layers
            obj.ngs=obj.ngs.*+obj.tel;
            % Saving the turbulence aberrated phase
            %turbPhase = ngs.meanRmPhase;
            % Variance of the atmospheric wavefront
            obj.total(kIteration) = var(obj.ngs);
            % Propagation to the WFS
            obj.ngs=obj.ngs*obj.dm*obj.wfs;
            
            % Variance of the residual wavefront
            loss = var(obj.ngs);
            obj.residue(kIteration) = loss;
            
            % contrast calculations
            if obj.contrast
                obj.science =obj.science.*obj.tel;
                obj.science = obj.science*obj.dm;
                
                phase = obj.science.meanRmPhase;
                amp = obj.science.mask;
                
                P = amp.*exp(1i.*phase);
                P = padarray(P,[40*16 40*16],0);
     
                C1 = efc(P);
                [C2 ,ce] = efc_pc(P);
            
                obj.C = obj.C + (abs(C1).^2);
                obj.C_post = obj.C_post + (abs(C2).^2);
            % end contrast
            end
            
            if  numel(control) == 1 
                if obj.z
                    control = zeros(obj.nmodes-1,1);
                    
                else    
                    control = zeros(obj.wfs.lenslets.nLenslet +1);
                end
                
                
            end
            
            xData = obj.wfs.xSlopesMap;
            yData = obj.wfs.ySlopesMap;            
            
            zernikeData = obj.S2M*obj.wfs.slopes;
            zernikeData = zernikeData./obj.std_modes;
            
            %zernikeData = zernikeData*obj.wfs.wavefrontUnits;
                        
            if obj.z
                %dmCoefs = obj.V2M*obj.dm.coefs;
                dmCoefs = obj.prev_modes;
                obj.prev_modes = control;
                
                temp = control;
                
                temp = temp.*obj.std_modes;
                obj.dm.coefs = -obj.M2V*(temp);
                                
            else    
                dmCoefs = zeros( obj.dm.nActuator );
                dmCoefs(obj.wfs.validActuator) =  obj.dm.coefs./3.1969e-07;
                
                control = control(obj.wfs.validActuator);   
                
                obj.dm.coefs = control.*3.1969e-07;
            end
                                   
            % control with closed loop integrator                                  
            if obj.z                 
                intcontrol =  0.5*zernikeData + temp;
                intcontrol = intcontrol;%(2:obj.nmodes);
                zernikeData = zernikeData;%(2:obj.nmodes);
            else
                residualDmCoefs = (obj.S2V*obj.wfs.slopes);%wfs.slopes;%
                zernikeData = -residualDmCoefs;
                intcontrol = zeros( obj.dm.nActuator );            
                intcontrol(obj.wfs.validActuator) =  (- 0.5*residualDmCoefs + obj.dm.coefs)./3.1969e-07;
            end
            
            loss = norm(zernikeData);
            
        end
        
        function [ dmShape, ngsRes, data] = render(obj)
            dmShape = obj.dm.surface;
            wfsData = zeros( obj.dm.nActuator );
            wfsData(obj.wfs.validActuator) = obj.wfs.finiteDifferenceWavefront;
            data = wfsData;
            ngsRes = obj.ngs.meanRmOpd;
            
        end    
        
        function [marechalStrehl] = eval_env(obj, nIteration)
            %u = double(0:nIteration-1).*obj.tel.samplingTime;
            obj.atm.wavelength = obj.ngs.wavelength;
           
            % Piston removed phase variance
            %totalTheory = phaseStats.zernikeResidualVariance(1,obj.atm,obj.tel);
            obj.atm.wavelength = photometry.V;
            
            % Phase variance to micron rms converter 
            rmsMicron = @(x) 1e6*sqrt(x).*obj.ngs.wavelength/2/pi;         
            marechalStrehl =  100*exp(-(mean(rmsMicron(obj.residue(50:nIteration)))*1e-6/obj.ngs.wavelength*2*pi)^2*(obj.atm.wavelength/obj.science(1).wavelength)^2);

        end
        
        function [residue, C , C_post] = eval_episode_env(obj, nIteration)              
            rmsMicron = @(x) 1e6*sqrt(x).*obj.ngs.wavelength/2/pi;
            residue =  rmsMicron(obj.residue(1:nIteration));
            
            if obj.contrast
                C = obj.C./nIteration;
                C_post = obj.C_post./nIteration;
            else
                C = [];
                C_post = [];
            end
        end
        
        
        
    end
end

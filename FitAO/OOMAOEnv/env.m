classdef env < handle
    % ENV
    % Jalo Nousiainen 04/2019
    % enviroment for a reinforcement learner

    properties
        tel;
        dm;
        wfs;
        gs;
        cam;
        V2S;
        S2V;
        science;
        atm;
        d;
        gsRes;
        D;
    end

    methods
        function obj = env()

            addpath([pwd '/oomao-master']);

        end

        function [pm] = lambda2photometry(obj,wavelength)
            % Transform raw wavelengths to photometry objects used by
            % OOMAO. If exact match is not found use the closest wavelength
            addpath([pwd '/oomao-master']);

            photometry_list = [photometry.U,photometry.B,photometry.V,photometry.R,photometry.I,photometry.J,photometry.H,photometry.K,photometry.L,photometry.M];

            photometry_l = [0.36, 0.44, 0.55, 0.64, 0.79, 1.22, 1.65, 2.18, 3.55, 4.77];

            [d, idx] =  min(abs(photometry_l-wavelength));

            pm = photometry_list(idx)

        end


        function [S2V] = get_S2V(obj)
            % Return control matrix generated by OOMAO
            S2V = obj.S2V;

        end

        function [] = set_tel_params(obj, diameter, obs_ratio, sampling_time, nPx)
          % Setting telescope parameters
            addpath([pwd '/oomao-master']);

            tel = telescope(diameter,...
                'fieldOfViewInArcMin',2.5,...
                'resolution',nPx,...
                'samplingTime',sampling_time, 'obStructionRatio', obs_ratio);

            obj.tel = tel;

        end

        function [] = set_science_params(obj, sc_mag, sc_wavelen)
          % Setting guide star and science object parameters
            addpath([pwd '/oomao-master']);

            obj.science = source('wavelength',obj.lambda2photometry(sc_wavelen));
            obj.science.magnitude = sc_mag

        end

        function [] = set_ngs_params(obj, gs_mag, gs_wavelen)
          % Setting guide star and science object parameters
            addpath([pwd '/oomao-master']);

            obj.gs = source('wavelength',obj.lambda2photometry(gs_wavelen));
            obj.gs.magnitude = gs_mag

        end

        function [] = set_lgs_params(obj, gs_mag, gs_wavelen, alt, lltx, llty, xpos, ypos)
          % Setting guide star and science object parameters
            addpath([pwd '/oomao-master']);

            %obj.gs = source('wavelength',photometry.Na,'height',linspace(alt-5e3,alt+5e3,11),'zenith',sqrt(xpos^2 + ypos^2)*constants.arcsec2radian);
            obj.gs = source('wavelength',obj.lambda2photometry(gs_wavelen),'height',alt,'zenith',sqrt(xpos^2 + ypos^2)*constants.arcsec2radian,'viewPoint',[lltx,llty]);
            %obj.gs = source('asterism',{[3,arcsec(15),0]},'height',[88,92]*1e3);
            set(obj.gs,'objectiveFocalLength',90e3)
            obj.gs.magnitude = gs_mag

        end

        function [] = set_sh_params(obj,nLenslet,nPx,fracsub,noise)
          % Setting up wavefront sensor
            addpath([pwd '/oomao-master']);

            wfs = shackHartmann(nLenslet,nPx,fracsub);

            % Propagation of the calibration source to the WFS through the telescope
            gs = obj.gs.*obj.tel*wfs;
            wfs.INIT
            +wfs;

            if noise == 0
                wfs.camera.photonNoise = true;
            elseif noise > 0
                wfs.camera.photonNoise = true;
                wfs.camera.readOutNoise = noise;
            else
                wfs.camera.photonNoise = false;
                wfs.camera.readOutNoise = 0;
            end

            wfs.framePixelThreshold = 5;

            obj.wfs = wfs;

        end

        function [] = set_pyr_params(obj,nLenslet,fssize,fracsub,noise,amplitude,separation,npts,nPx)
          % Setting up wavefront sensor
            addpath([pwd '/oomao-master']);

            wfs = pyramid(nLenslet,nPx,'modulation',amplitude,'minLightRatio',fracsub,'c',1+(separation/nLenslet));

            % Propagation of the calibration source to the WFS through the telescope
            gs = obj.gs.*obj.tel*wfs;
            wfs.INIT
            +wfs;

            if noise == 0
                wfs.camera.photonNoise = true;
            elseif noise > 0
                wfs.camera.photonNoise = true;
                wfs.camera.readOutNoise = noise;
            else
                wfs.camera.photonNoise = false;
                wfs.camera.readOutNoise = 0;
            end

            wfs.framePixelThreshold = 5;

            obj.wfs = wfs;

        end

        function [] = set_dm_params(obj,  nLenslet, nPx, coupling)
          % Setting up deformable mirror
            addpath([pwd '/oomao-master']);

            %bif = influenceFunction('monotonic',20/100);
            bif = gaussianInfluenceFunction(coupling,obj.tel.D/nLenslet); %coupling,
            nActuator = nLenslet + 1;


            %dm0 = deformableMirror(param.nAct,'modes',bif0,'resolution',tel.resolution,...
            %'diameter',tel.D,'validAct',wfs.validActuator);

            %mag = obj.gs.magnitude, %save for after calib

            %gs = obj.gs;

            gs.magnitude = 0;

            obj.dm = deformableMirror(nActuator,...
            'modes',bif,...
            'resolution',nPx,...
            'validActuator',obj.wfs.validActuator);

            %gs=obj.gs.*obj.tel;


            %try
            %    load('calibration_vlt','dmCalib');
            %catch
            %    warning('no precomputed calibration')
            %dmCalib = calibration(dm,obj.wfs,gs,gs.wavelength, nLenslet+1,'cond',cond)
            %    save('calibration_vlt','dmCalib')
            %end
            %dmCalib.nThresholded = 12;

            close all

            %obj.dm = dm;

            %obj.S2V = dmCalib.M;
            %obj.V2S = dmCalib.D;

        end

        function [V2S] = get_imat(obj)
            % Return interaction matrix generated by OOMAO
            V2S = obj.V2S

        end

        function [] = set_atmos_params(obj, windSpeed, windDirection, r0, L0, frac_r0, altitude, seed)
            % Setting up atmosphere
            addpath([pwd '/oomao-master']);

            if seed < 0
                rng('shuffle')
                disp('seed empty')
                ss = RandStream('mt19937ar','Seed',randi(1e8,1));
            else
                disp('seed given')
                rng(seed)
                ss = RandStream('mt19937ar','Seed',seed);
            end

            if length(L0) > 1
                L0 = L0';
            else
                L0 = L0(1);
            end

            atm = atmosphere(photometry.V,r0,L0,...
            'altitude',altitude,...
            'fractionnalR0',frac_r0,...
            'windSpeed',windSpeed,...
            'windDirection',windDirection*pi/180,'randStream',ss);

            obj.atm = atm;
            obj.tel = obj.tel+atm;

        end

        function [] = set_cam(obj)
            % Setting up science cam
            addpath([pwd '/oomao-master']);

            obj.cam = imager();

            obj.science = obj.science.*obj.tel*obj.cam;

            % Setting up reference frame for Strehl-ratio calculations
            obj.tel = obj.tel - obj.atm;
            +obj.science;
            obj.cam.referenceFrame = obj.cam.frame;
            +obj.science;
            obj.cam.strehl;
            obj.tel = obj.tel + obj.atm;
            +obj.science;

            obj.science = obj.science.*obj.tel;
            obj.science = obj.science*obj.dm*obj.cam;

        end

        function [action, obs] = get_spaces(obj)
            % Return example objects of actions and observations used for
            % defining spaces in the gym enviroment
            action = obj.wfs.validActuator;
            obs = obj.wfs.slopes;

        end

        function [strehl] = get_strehl(obj)
            % Returns Strehl-ratio for current frame
            +obj.science;
            strehl = obj.cam.strehl;
            %imagesc(obj.cam);

        end

      function [] = clr(obj)
          obj.tel = NaN;
          obj.dm = NaN;
          obj.wfs = NaN;
          obj.gs = NaN;
          obj.cam = NaN;
          obj.V2S = NaN;
          obj.S2V = NaN;
          obj.science = NaN;
          obj.atm = NaN;
          obj.d = NaN;
          obj.gsRes = NaN;
          obj.D = NaN;

      end

      function [slopes] = rst(obj)
            % Resets dm commands and returns slopes

            addpath([pwd '/oomao-master']);

            % Resetting the DM command
            obj.dm.coefs = 0;

            % Propagation throught the atmosphere to the telescope
            obj.gs=obj.gs.*obj.tel;
            obj.gs=obj.gs*obj.dm*obj.wfs;
            obj.gsRes = obj.gs.meanRmOpd;

            slopes = obj.wfs.slopes;

            obj.gs=obj.gs.*+obj.tel;

      end

        function [slopes, done, info] = step(obj,showAtmos)
            % Single simulation step. showAtmos dictates if atmosphere is shown
            % to the WFS

            if showAtmos == false
                obj.tel = obj.tel - obj.atm
            end
            obj.gs=obj.gs*obj.dm*obj.wfs;
            obj.gsRes = obj.gs.meanRmOpd;
            slopes = obj.wfs.slopes;
            % Propagation throught the atmosphere to the telescope, +tel means that
            % all the layers move of one step based on the sampling time and the
            % wind vectors of the layers
            obj.gs=obj.gs.*+obj.tel;

            if showAtmos == false
                obj.tel = obj.tel + obj.atm
            end
            % Saving the turbulence aberrated phase
            %turbPhase = gs.meanRmPhase;
            % Variance of the atmospheric wavefront
            %obj.total(kIteration) = var(obj.gs);
            % Propagation to the WFS
            %obj.gs=obj.gs*obj.dm*obj.wfs;

            % Variance of the residual wavefront
            %loss = var(obj.gs);
            %obj.residue(kIteration) = loss;

            %slopes = obj.wfs.slopes;

            %reward = -1 * norm(slopes);

            done = 0;

            info = [];

        end

        function [] = applyControl(obj,control)

            obj.dm.coefs = control;

        end

        function [ dmShape, gsRes, atmos, img, wfs_img] = render(obj)
            dmShape = obj.dm.surface;

            gsRes = obj.gsRes;

            atmos = obj.gs.meanRmOpd;

            +obj.science;
            img = obj.cam.frame;

            wfs_img = obj.wfs.camera.frame;
        end

        function [dmShape] = get_dm_shape(obj)
            dmShape = obj.dm.surface;
        end

        function [gsRes] = get_phase_screen(obj)
          %gsRes = obj.gsRes;
          gsRes = obj.science.meanRmPhase;
        end

        function [valid] = get_valid(obj)
            valid = obj.wfs.validActuator;
        end

        function [pupil] = get_pupil(obj)
            pupil = obj.tel.pupil;
        end

        function [pPerSubap] = get_photonpsubap(obj)
            % It can be useful to know the number of photon per subaperture. To do so,
            % let separate the atmosphere from the telescope. Not working!
            obj.tel = obj.tel - obj.atm;
            obj.gs = obj.gs.*obj.tel*obj.wfs;

            intensity = zeros(obj.wfs.lenslets.nLenslet,obj.wfs.lenslets.nLenslet*obj.wfs.lenslets.nArray);
            v = obj.wfs.validLenslet(:);
            v = repmat(v,obj.wfs.lenslets.nArray,1);
            intensity(v) = obj.wfs.lensletIntensity;

            obj.tel = obj.tel + obj.atm;
            obj.gs = obj.gs.*obj.tel*obj.wfs;

            pPerSubap = max(intensity(:));
        end

        function [M2C] = get_KL_modes2volt(obj)
            addpath([pwd '/oomao-master']);
            zeropadding = 2;
            [KL,M2C]=KLBasisDecomposition(obj.tel,obj.atm,obj.dm,zeropadding);
        end

    end
end
